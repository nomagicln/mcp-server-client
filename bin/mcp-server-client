#!/usr/bin/env node

/**
 * MCP Server Client CLI
 *
 * 全局安装后的命令行入口
 */

import { spawn } from 'child_process';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
// 内部模块（ESM 静态导入）
import { resolveConfig } from '../src/config/loader.js';
import {
  LocalFileLoader,
  RemoteApiLoader,
} from '../src/resources/loaders/index.js';
import ResourceRegistry from '../src/resources/registry/ResourceRegistry.js';

// 获取当前文件所在目录
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// 构建主入口文件路径
const mainScript = join(__dirname, '..', 'src', 'index.js');

// 解析命令行参数
const args = process.argv.slice(2);

// 支持的命令
const commands = {
  start: {
    description: '启动 MCP 服务器',
    action: () => startServer(),
  },
  version: {
    description: '显示版本信息',
    action: () => showVersion(),
  },
  help: {
    description: '显示帮助信息',
    action: () => showHelp(),
  },
  'list-transports': {
    description: '列出支持的传输方式',
    action: () => listTransports(),
  },
  'list-resources': {
    description: '列出已注册的资源（按配置加载），支持筛选与分页',
    action: () => listResourcesCommand(),
  },
};

/**
 * 启动服务器
 */
function startServer() {
  console.log('🚀 启动 MCP Server Client...');

  // 解析传输参数
  const startArgs = args.slice(1); // 排除 'start'
  let transport = null;
  let configPath = null;
  let watchConfig = false;
  const passthrough = [];

  for (let i = 0; i < startArgs.length; i += 1) {
    const a = startArgs[i];
    if (a === '--transport' || a === '-t') {
      if (startArgs[i + 1]) {
        transport = startArgs[i + 1];
        i += 1;
      }
      continue;
    }
    if (a === '--config') {
      if (startArgs[i + 1]) {
        configPath = startArgs[i + 1];
        i += 1;
      }
      continue;
    }
    if (a === '--watch-config' || a === '-w') {
      watchConfig = true;
      continue;
    }
    // 其他未知参数透传给主进程（如将来新增的选项）
    passthrough.push(a);
  }

  const nodeArgs = [mainScript];
  if (transport) {
    nodeArgs.push('--transport', transport);
    console.log(`📡 使用传输方式: ${transport}`);
  }
  if (configPath) {
    nodeArgs.push('--config', configPath);
    console.log(`🧩 使用配置文件: ${configPath}`);
  }
  if (passthrough.length > 0) {
    nodeArgs.push(...passthrough);
  }

  // 启动主服务器进程
  const child = spawn('node', nodeArgs, {
    stdio: 'inherit',
    env: {
      ...process.env,
      NODE_ENV: 'production',
      // 仅当通过 CLI 指定 -w/--watch-config 时强制开启；否则沿用现有环境变量
      ...(watchConfig ? { MCP_WATCH_CONFIG: '1' } : {}),
    },
  });

  if (watchConfig) {
    console.log('👀 已启用配置热更新 (MCP_WATCH_CONFIG=1)');
  }

  // 处理进程信号
  process.on('SIGINT', () => {
    console.log('\n⚠️  收到中断信号，正在关闭服务器...');
    child.kill('SIGINT');
  });

  process.on('SIGTERM', () => {
    console.log('\n⚠️  收到终止信号，正在关闭服务器...');
    child.kill('SIGTERM');
  });

  // 监听子进程退出
  child.on('exit', (code, signal) => {
    if (signal) {
      console.log(`\n✅ 服务器已通过信号 ${signal} 停止`);
    } else {
      console.log(
        `\n${code === 0 ? '✅' : '❌'} 服务器已退出，退出码: ${code}`,
      );
    }
    process.exit(code || 0);
  });

  child.on('error', error => {
    console.error('❌ 启动服务器时发生错误:', error.message);
    process.exit(1);
  });
}

/**
 * 显示版本信息
 */
async function showVersion() {
  try {
    const packagePath = join(__dirname, '..', 'package.json');
    const { default: pkg } = await import(packagePath, {
      with: { type: 'json' },
    });

    console.log(`📦 MCP Server Client v${pkg.version}`);
    console.log(`🏠 主页: ${pkg.repository?.url || 'N/A'}`);
    console.log(`👤 作者: ${pkg.author || 'N/A'}`);
    console.log(`📝 许可证: ${pkg.license || 'N/A'}`);
  } catch (error) {
    console.error('❌ 无法读取版本信息:', error.message);
    process.exit(1);
  }
}

/**
 * 列出支持的传输方式
 */
function listTransports() {
  console.log(`
🚀 MCP Server Client - 支持的传输方式

📡 可用传输方式:
  stdio              标准输入输出传输（默认）
  sse                服务器发送事件传输
  http               HTTP 流式传输

🌟 使用方法:
  mcp-server-client start --transport stdio    # 使用 stdio
  mcp-server-client start --transport sse      # 使用 SSE
  mcp-server-client start --transport http     # 使用 HTTP
  
  # 简化写法
  mcp-server-client start -t sse               # 使用 SSE
  mcpsc start -t http                          # 使用 HTTP

📋 传输方式说明:
  stdio    - 通过标准输入输出通信，适合本地进程调用
  sse      - 通过 Server-Sent Events 通信，支持 Web 客户端
  http     - 通过 HTTP POST 通信，支持 RESTful 客户端

🔧 环境变量:
  MCP_TRANSPORT=sse                           # 设置默认传输方式
  MCP_SSE_PORT=3001                          # SSE 端口
  MCP_HTTP_PORT=3002                         # HTTP 端口
  MCP_CONFIG=./mcp.config.js                 # 指定配置文件路径（JSON/JS）
  MCP_WATCH_CONFIG=1                         # 启用配置热更新
`);
}

/**
 * list-resources 命令实现
 * 支持选项：
 *   --config <path>
 *   --type <host|api>
 *   --loader <local|remote>
 *   --cap <capability>   可重复或逗号分隔
 *   --label <k=v>        可重复
 *   --limit <n>
 *   --offset <n>
 */
function listResourcesCommand() {
  const lrArgs = args.slice(1); // 排除 'list-resources'
  let configPath = null;
  const filter = { labels: {}, capabilities: [] };
  const pagination = {};

  for (let i = 0; i < lrArgs.length; i += 1) {
    const a = lrArgs[i];
    if (a === '--config' && lrArgs[i + 1]) {
      configPath = lrArgs[++i];
      continue;
    }
    if (a === '--type' && lrArgs[i + 1]) {
      filter.type = lrArgs[++i];
      continue;
    }
    if (a === '--loader' && lrArgs[i + 1]) {
      filter.loaderType = lrArgs[++i];
      continue;
    }
    if (a === '--cap' && lrArgs[i + 1]) {
      const val = lrArgs[++i];
      filter.capabilities.push(
        ...String(val)
          .split(',')
          .map(s => s.trim())
          .filter(Boolean),
      );
      continue;
    }
    if (a === '--label' && lrArgs[i + 1]) {
      const kv = String(lrArgs[++i]);
      const eq = kv.indexOf('=');
      if (eq > 0) {
        const k = kv.slice(0, eq);
        const v = kv.slice(eq + 1);
        filter.labels[k] = v;
      }
      continue;
    }
    if (a === '--limit' && lrArgs[i + 1]) {
      pagination.limit = parseInt(lrArgs[++i], 10);
      continue;
    }
    if (a === '--offset' && lrArgs[i + 1]) {
      pagination.offset = parseInt(lrArgs[++i], 10);
      continue;
    }
  }

  (async () => {
    try {
      const { config: fileConfig } = await resolveConfig({
        cliPath: configPath || undefined,
        envPath: process.env.MCP_CONFIG,
        allowFallback: true,
      });

      const registry = new ResourceRegistry();
      const resConf = fileConfig?.resources;
      if (resConf && Array.isArray(resConf.loaders)) {
        for (const loaderCfg of resConf.loaders) {
          const { type, id } = loaderCfg || {};
          if (!type || !id) continue;
          let loader = null;
          if (type === 'local') {
            loader = new LocalFileLoader({ files: loaderCfg.files || [] });
          } else if (type === 'remote') {
            loader = new RemoteApiLoader({
              baseUrl: loaderCfg.baseUrl,
              headers: loaderCfg.headers,
              auth: loaderCfg.auth,
              timeoutMs: loaderCfg.timeoutMs,
            });
          }
          if (!loader || typeof loader.loadResources !== 'function') continue;
          try {
            const { resources } = await loader.loadResources();
            for (const r of resources || []) {
              const rid = typeof r?.id === 'string' ? r.id : null;
              const rtype = typeof r?.type === 'string' ? r.type : null;
              if (!rid || !rtype) continue;
              const identifier = `${rtype}://${type}/${id}/${rid}`;
              registry.registerResource(identifier, r);
            }
          } catch (e) {
            // 忽略某个 loader 的失败，继续其他
          }
        }
      }

      const { resources, total, filtered } = registry.listResources({
        filter,
        pagination,
      });
      const simplified = resources.map(({ identifier, resource }) => ({
        identifier,
        id: resource?.id,
        type: resource?.type,
        name: resource?.name,
        capabilities: resource?.capabilities,
        labels: resource?.labels,
      }));
      // 输出 JSON
      process.stdout.write(
        JSON.stringify({ total, filtered, resources: simplified }, null, 2) +
          '\n',
      );
      process.exit(0);
    } catch (error) {
      console.error('❌ 列出资源失败:', error.message);
      process.exit(1);
    }
  })();
}

/**
 * 显示帮助信息
 */
function showHelp() {
  console.log(`
🔧 MCP Server Client - 命令行工具

📖 使用方法:
  mcp-server-client <command> [options]
  mcpsc <command> [options]         # 简化命令

📋 可用命令:
`);

  // 显示所有命令
  Object.entries(commands).forEach(([cmd, info]) => {
    console.log(`  ${cmd.padEnd(12)} ${info.description}`);
  });

  console.log(`
📚 示例:
  mcp-server-client start                          启动 MCP 服务器（默认 stdio）
  mcp-server-client start -t sse                   使用 SSE 传输启动
  mcp-server-client start -t http                  使用 HTTP 传输启动
  mcp-server-client start --config ./mcp.config.js 使用指定配置文件
  mcp-server-client start -w                       启用配置热更新（等同 MCP_WATCH_CONFIG=1）
  mcp-server-client version        查看版本信息
  mcp-server-client list-transports 列出支持的传输方式
  
  mcpsc start -t sse               使用简化命令和 SSE 传输

🌐 更多信息:
  查看项目文档: https://github.com/nomagicln/mcp-server-client

⚙️ 启动选项:
  -t, --transport <type>            传输方式: stdio | sse | http
      --config <path>               指定配置文件（覆盖 MCP_CONFIG）
  -w, --watch-config                启用配置热更新 (设置 MCP_WATCH_CONFIG=1)

📦 配置加载优先级:
  1) --config 指定路径
  2) 环境变量 MCP_CONFIG 指定路径
  3) 默认搜索: CWD / ~/.config/mcp-server-client / /etc/mcp-server-client 下的
     mcp.config.json | mcp.config.js | mcp.config.mjs | mcp.config.cjs

🔧 开发命令 (在项目目录中):
  make help                        查看所有 Makefile 命令
  npm run dev                      开发模式启动
  npm test                         运行测试
`);
}

/**
 * 主函数
 */
function main() {
  // 如果没有参数或参数为空，显示帮助
  if (args.length === 0) {
    showHelp();
    return;
  }

  const command = args[0];

  // 执行命令
  if (commands[command]) {
    commands[command].action();
  } else {
    console.error(`❌ 未知命令: ${command}`);
    console.log('💡 运行 "mcp-server-client help" 查看可用命令');
    process.exit(1);
  }
}

// 处理未捕获的异常
process.on('uncaughtException', error => {
  console.error('❌ 未捕获的异常:', error.message);
  process.exit(1);
});

process.on('unhandledRejection', reason => {
  console.error('❌ 未处理的 Promise 拒绝:', reason);
  process.exit(1);
});

// 启动 CLI
main();
