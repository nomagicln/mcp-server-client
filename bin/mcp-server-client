#!/usr/bin/env node

/**
 * MCP Server Client CLI
 *
 * 全局安装后的命令行入口
 */

import { spawn } from 'child_process';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

// 获取当前文件所在目录
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// 构建主入口文件路径
const mainScript = join(__dirname, '..', 'src', 'index.js');

// 解析命令行参数
const args = process.argv.slice(2);

// 支持的命令
const commands = {
  start: {
    description: '启动 MCP 服务器',
    action: () => startServer(),
  },
  version: {
    description: '显示版本信息',
    action: () => showVersion(),
  },
  help: {
    description: '显示帮助信息',
    action: () => showHelp(),
  },
  'list-transports': {
    description: '列出支持的传输方式',
    action: () => listTransports(),
  },
};

/**
 * 启动服务器
 */
function startServer() {
  console.log('🚀 启动 MCP Server Client...');

  // 解析传输参数
  const startArgs = args.slice(1); // 排除 'start'
  let transport = null;
  let configPath = null;
  let watchConfig = false;
  const passthrough = [];

  for (let i = 0; i < startArgs.length; i += 1) {
    const a = startArgs[i];
    if (a === '--transport' || a === '-t') {
      if (startArgs[i + 1]) {
        transport = startArgs[i + 1];
        i += 1;
      }
      continue;
    }
    if (a === '--config') {
      if (startArgs[i + 1]) {
        configPath = startArgs[i + 1];
        i += 1;
      }
      continue;
    }
    if (a === '--watch-config' || a === '-w') {
      watchConfig = true;
      continue;
    }
    // 其他未知参数透传给主进程（如将来新增的选项）
    passthrough.push(a);
  }

  const nodeArgs = [mainScript];
  if (transport) {
    nodeArgs.push('--transport', transport);
    console.log(`📡 使用传输方式: ${transport}`);
  }
  if (configPath) {
    nodeArgs.push('--config', configPath);
    console.log(`🧩 使用配置文件: ${configPath}`);
  }
  if (passthrough.length > 0) {
    nodeArgs.push(...passthrough);
  }

  // 启动主服务器进程
  const child = spawn('node', nodeArgs, {
    stdio: 'inherit',
    env: {
      ...process.env,
      NODE_ENV: 'production',
      // 仅当通过 CLI 指定 -w/--watch-config 时强制开启；否则沿用现有环境变量
      ...(watchConfig ? { MCP_WATCH_CONFIG: '1' } : {}),
    },
  });

  if (watchConfig) {
    console.log('👀 已启用配置热更新 (MCP_WATCH_CONFIG=1)');
  }

  // 处理进程信号
  process.on('SIGINT', () => {
    console.log('\n⚠️  收到中断信号，正在关闭服务器...');
    child.kill('SIGINT');
  });

  process.on('SIGTERM', () => {
    console.log('\n⚠️  收到终止信号，正在关闭服务器...');
    child.kill('SIGTERM');
  });

  // 监听子进程退出
  child.on('exit', (code, signal) => {
    if (signal) {
      console.log(`\n✅ 服务器已通过信号 ${signal} 停止`);
    } else {
      console.log(
        `\n${code === 0 ? '✅' : '❌'} 服务器已退出，退出码: ${code}`,
      );
    }
    process.exit(code || 0);
  });

  child.on('error', error => {
    console.error('❌ 启动服务器时发生错误:', error.message);
    process.exit(1);
  });
}

/**
 * 显示版本信息
 */
async function showVersion() {
  try {
    const packagePath = join(__dirname, '..', 'package.json');
    const { default: pkg } = await import(packagePath, {
      with: { type: 'json' },
    });

    console.log(`📦 MCP Server Client v${pkg.version}`);
    console.log(`🏠 主页: ${pkg.repository?.url || 'N/A'}`);
    console.log(`👤 作者: ${pkg.author || 'N/A'}`);
    console.log(`📝 许可证: ${pkg.license || 'N/A'}`);
  } catch (error) {
    console.error('❌ 无法读取版本信息:', error.message);
    process.exit(1);
  }
}

/**
 * 列出支持的传输方式
 */
function listTransports() {
  console.log(`
🚀 MCP Server Client - 支持的传输方式

📡 可用传输方式:
  stdio              标准输入输出传输（默认）
  sse                服务器发送事件传输
  http               HTTP 流式传输

🌟 使用方法:
  mcp-server-client start --transport stdio    # 使用 stdio
  mcp-server-client start --transport sse      # 使用 SSE
  mcp-server-client start --transport http     # 使用 HTTP
  
  # 简化写法
  mcp-server-client start -t sse               # 使用 SSE
  mcpsc start -t http                          # 使用 HTTP

📋 传输方式说明:
  stdio    - 通过标准输入输出通信，适合本地进程调用
  sse      - 通过 Server-Sent Events 通信，支持 Web 客户端
  http     - 通过 HTTP POST 通信，支持 RESTful 客户端

🔧 环境变量:
  MCP_TRANSPORT=sse                           # 设置默认传输方式
  MCP_SSE_PORT=3001                          # SSE 端口
  MCP_HTTP_PORT=3002                         # HTTP 端口
  MCP_CONFIG=./mcp.config.js                 # 指定配置文件路径（JSON/JS）
  MCP_WATCH_CONFIG=1                         # 启用配置热更新
`);
}

/**
 * 显示帮助信息
 */
function showHelp() {
  console.log(`
🔧 MCP Server Client - 命令行工具

📖 使用方法:
  mcp-server-client <command> [options]
  mcpsc <command> [options]         # 简化命令

📋 可用命令:
`);

  // 显示所有命令
  Object.entries(commands).forEach(([cmd, info]) => {
    console.log(`  ${cmd.padEnd(12)} ${info.description}`);
  });

  console.log(`
📚 示例:
  mcp-server-client start                          启动 MCP 服务器（默认 stdio）
  mcp-server-client start -t sse                   使用 SSE 传输启动
  mcp-server-client start -t http                  使用 HTTP 传输启动
  mcp-server-client start --config ./mcp.config.js 使用指定配置文件
  mcp-server-client start -w                       启用配置热更新（等同 MCP_WATCH_CONFIG=1）
  mcp-server-client version        查看版本信息
  mcp-server-client list-transports 列出支持的传输方式
  
  mcpsc start -t sse               使用简化命令和 SSE 传输

🌐 更多信息:
  查看项目文档: https://github.com/nomagicln/mcp-server-client

⚙️ 启动选项:
  -t, --transport <type>            传输方式: stdio | sse | http
      --config <path>               指定配置文件（覆盖 MCP_CONFIG）
  -w, --watch-config                启用配置热更新 (设置 MCP_WATCH_CONFIG=1)

📦 配置加载优先级:
  1) --config 指定路径
  2) 环境变量 MCP_CONFIG 指定路径
  3) 默认搜索: CWD / ~/.config/mcp-server-client / /etc/mcp-server-client 下的
     mcp.config.json | mcp.config.js | mcp.config.mjs | mcp.config.cjs

🔧 开发命令 (在项目目录中):
  make help                        查看所有 Makefile 命令
  npm run dev                      开发模式启动
  npm test                         运行测试
`);
}

/**
 * 主函数
 */
function main() {
  // 如果没有参数或参数为空，显示帮助
  if (args.length === 0) {
    showHelp();
    return;
  }

  const command = args[0];

  // 执行命令
  if (commands[command]) {
    commands[command].action();
  } else {
    console.error(`❌ 未知命令: ${command}`);
    console.log('💡 运行 "mcp-server-client help" 查看可用命令');
    process.exit(1);
  }
}

// 处理未捕获的异常
process.on('uncaughtException', error => {
  console.error('❌ 未捕获的异常:', error.message);
  process.exit(1);
});

process.on('unhandledRejection', reason => {
  console.error('❌ 未处理的 Promise 拒绝:', reason);
  process.exit(1);
});

// 启动 CLI
main();
